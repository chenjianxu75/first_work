# First_work
## 以下是每个项目的README示例：


- 1.用户登录、注册和密码修改功能（User Authentication）该项目使用Go语言实现了基本的用户登录、注册和密码修改功能。 
- 它提供以下功能：

> 注册新用户：用户可以输入用户名和密码进行注册。
> 用户登录：已注册的用户可以使用用户名和密码进行登录。
修改密码：登录后的用户可以更改他们的密码。
> 登录：输入正确的账号及密码登录进入账号
> 退出：退出账号登陆界面

#### 代码逻辑剖析：
在函数中，使用一个无限循环展示菜单选项，并根据用户的选择执行相应的功能。main用户可以选择注册、登录、修改密码或退出程序。
根据用户选择，调用相应的函数进行处理。
在每个功能函数中，通过读取用户输入进行相关操作，如注册新用户、验证登录信息或修改密码。
用户数据存储在变量中，以usersUsername作为键，User结构体作为值。

#### 重点部分详细介绍：
错误处理：在涉及用户输入的地方，使用err变量来捕获可能的错误。 如果读取输入时出现错误，将会打印错误信息并继续程序执行。
注册功能：在registerUser函数中，先读取用户名和密码，然后检查用户名是否已存在。如果存在，则提示用户重新输入。如果不存在，则将新用户信息存储到users变量中。
登录功能：在loginUser函数中，读取用户名和密码，并与已注册的用户信息进行验证。如果用户名或密码不匹配，将提示用户登录失败。
修改密码功能：在changePassword函数中，首先读取用户名和当前密码，然后检查用户是否存在以及当前密码是否正确。如果一切正常，将读取新密码，并更新用户信息。



- 2.并发控制示例（Concurrency Control）该项目使用Go语言展示了如何使用四个goroutine实现并发控制。 每个goroutine轮流打印 "张三"、"李四"、"王五" 和 "赵六" 这四个名字各100次。

#### 代码逻辑剖析：
在main函数中，我们创建了四个带缓冲的通道ch1、ch2、ch3和ch4，用于控制打印顺序。
创建了一个互斥锁mutex，用于保护计数器的更新操作。
创建了一个计数器counter，用于记录已打印的次数。
使用sync.WaitGroup来等待所有goroutine的完成。
启动四个goroutine，每个goroutine使用printName函数打印指定的名字，根据通道控制打印顺序，并更新计数器。
向第一个通道ch1发送一个初始值，以启动打印过程。
使用sync.WaitGroup等待所有goroutine完成后，关闭所有通道。

#### 重点部分详细介绍：
printName函数：该函数负责打印指定的名字，并根据通道控制打印顺序。
mutex.Lock()和mutex.Unlock()：使用互斥锁保护计数器的更新操作，以避免并发冲突。
*counter++：通过互斥锁保护的临界区内，对计数器进行原子递增操作。
fmt.Printf("%s (%d)\n", name, printCount)：打印当前名字和计数。
if printCount >= 400 { break }：当达到最大打印次数（400次）时，退出循环。
nextCh <- struct{}{}：向下一个通道发送一个值，以允许下一个goroutine继续进行打印。


![Example Image](https://github.com/chenjianxu75/first_work/blob/main/%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-08%20152338.png)


- 3.Go语言的优缺点和流行原因（Go Language Advantages and Popularity）该项目解释了Go语言的优点、大厂后台为何选择使用Go进行重构以及Go语言近年来的流行原因。 它提供以下内容：

> Go语言的优点：简洁易学，并发性能，高性能，强大标准库，强类型和安全性.
Go语言的缺点：相对较小的生态系统，依赖管理，错误处理方式的限制，泛型支持的缺失，高级语言特性的限制
大厂为何选择使用Go进行重构：高并发处理能力，资源效率，开发过程简化，并发和安全性
Go语言近年来的流行原因：云原生和微服务，开发者的接受度增加，社区支持和生态系统，性能和可拓展性


由于篇幅问题，在这里就不具体详细展开叙述有关以上GO优缺点的相关具体代码示例。
详细的示例分析见task_3文档

- 4.解决TCP粘包问题的示例（TCP Socket - Handling Sticky Packets）该项目使用Go语言编写了一个TCP Socket示例，解决了粘包问题。 它提供以下功能：

服务器端代码逻辑：

> 首先，在指定的端口（localhost:8080）上监听连接。
通过Accept方法接受客户端的连接请求，并为每个连接启动一个独立的协程处理。
在handleConnection函数中，首先打印客户端的连接信息。
通过bufio.NewReader创建一个读取器，用于逐行读取客户端发送的消息。
在一个无限循环中，先读取消息的长度前缀，然后根据长度读取实际的消息内容。
打印接收到的消息，然后构建一个回复消息。
先发送回复消息的长度前缀，再发送回复消息的内容。

客户端代码逻辑：
> 使用net.Dial方法连接到指定的服务器地址（localhost:8080）。
使用bufio.NewReader创建一个读取器，用于从标准输入读取用户输入的消息。
在一个无限循环中，提示用户输入消息并读取用户输入的内容。
根据消息的长度，先发送消息长度前缀，再发送消息的内容。
通过bufio.NewReader读取服务器端发送的回复消息的长度前缀。
根据回复消息的长度，读取回复消息的实际内容。
打印服务器端的回复消息。
重点部分解释：

服务器端：

> handleConnection函数中，通过reader.ReadBytes('\n')读取消息的长度前缀，直到遇到换行符。然后使用strconv.Atoi将字符串转换为整数，得到消息的长度。
使用make([]byte, messageLength)创建一个字节切片，用于存储实际的消息内容。
通过reader.Read读取指定长度的字节，将其存储到messageBytes中，得到实际的消息内容。
将messageBytes转换为字符串，即为接收到的消息内容。
使用conn.Write方法将回复消息的长度前缀和内容分两次发送给客户端。

客户端：
> 使用conn.Write方法将消息的长度前缀和内容分两次发送给服务器端。
通过bufio.NewReader读取服务器端发送的回复消息的长度前缀，直到遇到换行符。
使用strconv.Atoi将字符串转换为整数，得到回复消息的长度。
使用make([]byte, responseLength)创建一个字节切片，用于存储回复消息的内容。
通过conn.Read读取指定长度的字节，将其存储到responseBytes中，得到回复消息的实际内容。
将responseBytes转换为字符串，即为服务器端的回复消息。

该代码实现了一个简单的客户端和服务器端的通信过程。客户端可以向服务器端发送消息，服务器端接收并处理消息，并返回回复消息给客户端。展示了基本的TCP Socket通信的实现方式。
